"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PagesBuilder = void 0;

var _discord = require("discord.js");

var _interfaces = require("./interfaces");

var _utils = require("./utils");

class PagesBuilder extends _discord.MessageEmbed {
  constructor(interaction) {
    super();
    this.messageId = '';
    /**
     * Pages
     */

    this.pages = [];
    this.files = [];
    this.currentPage = 1;
    this.paginationFormat = '%c / %m';
    this.loop = true;
    /**
     * Components
     */

    this.components = [];
    this.defaultButtons = [];
    /**
     * Listen
     */

    this.listenTimeout = 5 * 60 * 1000;
    this.autoResetTimeout = true;
    this.endColor = 'GREY';
    this.endMethod = _interfaces.EndMethod.EDIT;
    /**
     * Triggers
     */

    this.triggers = new Map();
    this.interaction = interaction;
    this.listenUsers = [interaction.member.user.id];
    this.setDefaultButtons();
  }
  /**
   * Method for initial pages setup
   *
   * @example
   * ```
   * builder.setPages(
   *     new MessageEmbed()
   *         .setTitle('Hello World!')
   * );
   *
   * builder.setPages([
   *     new MessageEmbed()
   *         .setTitle('Hello World!'),
   *     () => (
   *         new MessageEmbed()
   *             .setTitle('Function page')
   *     )
   * ]);
   * ```
   */


  setPages(pages) {
    if (!Array.isArray(pages)) {
      pages = [pages];
    }

    this.pages = pages;
    return this;
  }
  /**
   * Method for adding pages to the end
   */


  addPages(pages) {
    this.pages = this.pages.concat(pages);
    return this;
  }
  /**
   * Method for initial files setup
   */


  setFiles(files) {
    if (!Array.isArray(files)) {
      files = [files];
    }

    this.files = files;
    return this;
  }
  /**
   * Method for adding files to the end
   */


  addFiles(files) {
    this.files = this.files.concat(files);
    return this;
  }
  /**
   * Method for auto generating pages
   *
   * @example
   * ```
   * builder.autoGeneratePages({
   *     items: [
   *         'Player 1',
   *         'Player 2',
   *         'Player 3'
   *     ],
   *     countPerPage: 2
   * });
   * ```
   */


  autoGeneratePages({
    items,
    countPerPage = 10
  }) {
    const chunks = (0, _utils.chunk)(items, countPerPage);
    this.setPages(chunks.map(chunk => new _discord.MessageEmbed().setDescription(chunk.join('\n'))));
    return this;
  }
  /**
   * Method for opening a specific page
   */


  async setPage(pageNumber) {
    this.currentPage = pageNumber;
    const data = {
      embeds: await this.getPage(pageNumber),
      components: this.simplifyKeyboard([...this.defaultButtons, ...this.components])
    };

    if (this.messageComponent) {
      const method = this.messageComponent.deferred || this.messageComponent.replied ? 'editReply' : 'update';
      return this.messageComponent[method](data);
    }

    if (this.buildMethod !== 'reply') {
      return this.message.edit(data);
    }

    return this.interaction.editReply(data);
  }
  /**
   * Method for getting the page
   */


  async getPage(pageNumber = this.currentPage) {
    let page = this.pages[pageNumber - 1];

    if (typeof page === 'function') {
      page = await page();
    }

    const clonedPage = new _discord.MessageEmbed(page);
    Object.keys(clonedPage).forEach(pageKey => {
      var _this$key2;

      const key = pageKey;

      switch (key) {
        case 'fields':
          clonedPage[key] = [...this[key], ...clonedPage[key]];
          break;

        case 'footer':
          {
            var _this$key;

            const footer = (_this$key = this[key]) !== null && _this$key !== void 0 ? _this$key : clonedPage[key];

            if (this.paginationFormat) {
              const pageNumber = this.paginationFormat.replace('%c', String(this.currentPage)).replace('%m', String(this.pages.length));

              if (footer) {
                clonedPage[key] = { ...footer,
                  text: `${pageNumber}${this.paginationFormat && footer.text ? ' â€¢ ' : ''}${footer.text}`
                };
              } else {
                clonedPage.setFooter({
                  text: pageNumber
                });
              }
            } else {
              var _footer$text;

              clonedPage.setFooter({
                text: (_footer$text = footer === null || footer === void 0 ? void 0 : footer.text) !== null && _footer$text !== void 0 ? _footer$text : ''
              });
            }

            break;
          }

        default:
          // @ts-ignore
          clonedPage[key] = (_this$key2 = this[key]) !== null && _this$key2 !== void 0 ? _this$key2 : clonedPage[key];
          break;
      }
    });
    return [clonedPage];
  }
  /**
   * Method for setting the pagination format
   *
   * @example
   * %c - Current page
   * %m - Max page
   *
   * ```
   * builder.setPaginationFormat('Current page: %c, Max: %m');
   * ```
   */


  setPaginationFormat(format = '%c / %m') {
    this.paginationFormat = format;
    return this;
  }
  /**
   * Method for setting endless page switching when reaching the end
   */


  setLoop(status = true) {
    this.loop = status;
    return this;
  }
  /**
   * Method for setting default buttons
   *
   * @example
   * ```
   * builder.setDefaultButtons(['first', {
   *   stop: new MessageButton()
   *      .setLabel('Stop')
   *      .setStyle('PRIMARY')
   * }]);
   * ```
   */


  setDefaultButtons(buttons = [_interfaces.Action.FIRST, _interfaces.Action.BACK, _interfaces.Action.STOP, _interfaces.Action.NEXT, _interfaces.Action.LAST]) {
    const defaultActions = new Map([[_interfaces.Action.FIRST, _interfaces.ActionLabel.FIRST], [_interfaces.Action.BACK, _interfaces.ActionLabel.BACK], [_interfaces.Action.STOP, _interfaces.ActionLabel.STOP], [_interfaces.Action.NEXT, _interfaces.ActionLabel.NEXT], [_interfaces.Action.LAST, _interfaces.ActionLabel.LAST]]);
    this.defaultButtons = buttons.length ? [new _discord.MessageActionRow().addComponents(buttons.map(button => {
      if (typeof button === 'string') {
        return new _discord.MessageButton().setCustomId(button).setEmoji(defaultActions.get(button)).setStyle('SECONDARY');
      }

      const [[buttonAction, buttonComponent]] = Object.entries(button);
      return buttonComponent.setCustomId(buttonAction);
    }))] : [];
    return this;
  }
  /**
   * Method for setting the time to listen for updates to switch pages
   */


  setListenTimeout(timeout = 5 * 60 * 1000) {
    this.listenTimeout = timeout;
    return this;
  }
  /**
   * @description Method for resetting the current listening timer
   */


  resetListenTimeout({
    isFirstBuild = false
  } = {}) {
    if (this.timeout || isFirstBuild) {
      clearTimeout(this.timeout);
      this.timeout = setTimeout(this.stopListen.bind(this), this.listenTimeout);
    }
  }
  /**
   * Method for setting embed color at the end of listening
   */


  setListenEndColor(color = 'GREY') {
    this.endColor = color;
    return this;
  }
  /**
   * Method for setting the method of working with a message when you finish listening for reactions
   */


  setListenEndMethod(method) {
    this.endMethod = method;
    return this;
  }
  /**
   * Method for setting listening to specific users
   */


  setListenUsers(users = []) {
    this.listenUsers = !Array.isArray(users) ? [users] : users;
    return this;
  }
  /**
   * Method for adding listening to specific users
   */


  addListenUsers(users) {
    this.listenUsers = this.listenUsers.concat(users);
    return this;
  }
  /**
   * Method for setting the timer to automatically reset when switching between pages
   */


  setAutoResetTimeout(status = true) {
    this.autoResetTimeout = status;
    return this;
  }
  /**
   * Method for early stopping listening
   */


  stopListen() {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.collector.stop();
    }
  }
  /**
   * Method for setting components rows
   */


  setComponents(components) {
    if (!Array.isArray(components)) {
      components = [components];
    }

    this.components = components;
    return this;
  }
  /**
   * Method for adding components to available row
   */


  addComponents(components) {
    if (!Array.isArray(components)) {
      components = [components];
    }

    components.forEach(component => {
      if (component instanceof _discord.MessageActionRow) {
        return this.components.push(component);
      }

      let length = this.components.length;

      if (!length) {
        this.components.push(new _discord.MessageActionRow());
        length++;
      }

      const row = this.components[length - 1];

      if (component.type !== 'SELECT_MENU' && row.components.length < 5 && row.components.findIndex(({
        type
      }) => type === 'SELECT_MENU') === -1) {
        row.addComponents(component);
      } else {
        this.components.push(new _discord.MessageActionRow().addComponents(component));
      }
    });
    return this;
  }
  /**
   * Method for update existing components
   *
   * @example
   * ```
   * const button = new MessageButton()
   *    .setCustomId('test')
   *    .setLabel('Test button')
   *    .setStyle('PRIMARY');
   *
   * builder.addComponents(button);
   *
   * button.setLabel('Primary button');
   *
   * builder.updateComponents(button);
   *
   * builder.rerender();
   * ```
   */


  updateComponents(components) {
    if (!Array.isArray(components)) {
      components = [components];
    }

    components.forEach(component => {
      this.components.forEach(row => {
        const index = row.components.findIndex(({
          customId
        }) => customId === component.customId);

        if (index !== -1) {
          row.spliceComponents(index, 1, component);
        }
      });
    });
    return this;
  }

  get appendedComponents() {
    return this.components;
  }
  /**
   * Method for initial setting of triggers
   */


  setTriggers(triggers = []) {
    if (!Array.isArray(triggers)) {
      triggers = [triggers];
    }

    this.triggers = new Map(triggers.map(({
      name,
      callback
    }) => [name, callback]));
    return this;
  }
  /**
   * Method for adding triggers
   */


  addTriggers(triggers) {
    if (!Array.isArray(triggers)) {
      triggers = [triggers];
    }

    triggers.forEach(({
      name,
      callback
    }) => this.triggers.set(name, callback));
    return this;
  }
  /**
   * Rerender current page
   */


  rerender() {
    return this.setPage(this.currentPage);
  }
  /**
   * Build method
   */


  async build() {
    if (this.pages.length === 0) {
      throw new TypeError('Pages not set');
    }

    const method = this.interaction.replied ? 'followUp' : this.interaction.deferred ? 'editReply' : 'reply';
    const response = await this.interaction[method]({
      embeds: await this.getPage(),
      files: this.files,
      components: this.simplifyKeyboard([...this.defaultButtons, ...this.components])
    }).then(message => {
      if (message) {
        this.messageId = message.id;
        this.message = message;
      }
    });
    this.buildMethod = method;

    if (!this.messageId) {
      await this.interaction.fetchReply().then(message => {
        this.messageId = message.id;
        this.message = message;
      });
    }

    this.startCollector();
    this.resetListenTimeout({
      isFirstBuild: true
    });
    return response;
  }
  /**
   * @hidden
   */


  simplifyKeyboard(rows) {
    if (this.loop && this.pages.length > 1) {
      return rows;
    }

    return rows.reduce((rows, row) => {
      row = new _discord.MessageActionRow(row);
      row.components = row.components.filter(({
        type,
        customId
      }) => type === 'BUTTON' ? (this.currentPage !== 1 || this.pages.length !== 1 || customId !== _interfaces.Action.FIRST && customId !== _interfaces.Action.BACK) && (this.currentPage !== this.pages.length || this.pages.length !== 1 || customId !== _interfaces.Action.LAST && customId !== _interfaces.Action.NEXT) : true);

      if (row.components.length) {
        rows.push(row);
      }

      return rows;
    }, []);
  }
  /**
   * @hidden
   */


  startCollector() {
    this.collector = this.interaction.channel.createMessageComponentCollector().on('collect', interaction => {
      if (interaction.message.id !== this.messageId) {
        return;
      }

      if (this.listenUsers.length) {
        var _interaction$member;

        if (!this.listenUsers.includes((_interaction$member = interaction.member) === null || _interaction$member === void 0 ? void 0 : _interaction$member.user.id)) {
          return;
        }
      }

      if (this.autoResetTimeout) {
        this.resetListenTimeout();
      }

      this.messageComponent = interaction;
      this.message = interaction.message;

      if (interaction.isButton()) {
        this.handleButton(interaction);
      }

      if (interaction.isSelectMenu()) {
        this.handleSelectMenu(interaction);
      }
    }).on('end', async () => {
      switch (this.endMethod) {
        case _interfaces.EndMethod.EDIT:
          {
            const embeds = await this.getPage();
            const [embed] = embeds;
            embed.setColor(this.endColor);
            this.message.edit({
              embeds,
              components: []
            }).catch(() => null);
            break;
          }

        case _interfaces.EndMethod.REMOVE_COMPONENTS:
          this.message.edit({
            components: []
          }).catch(() => null);
          break;

        case _interfaces.EndMethod.REMOVE_EMBEDS:
          this.message.edit({
            embeds: []
          }).catch(() => null);
          break;

        case _interfaces.EndMethod.DELETE:
          this.message.delete().catch(() => null);
          break;
      }
    });
  }
  /**
   * @hidden
   */


  async handleButton(interaction) {
    const {
      customId
    } = interaction;
    this.executeAction(customId);
    const trigger = this.triggers.get(customId);
    const buttons = [];

    if (trigger) {
      this.components.forEach(component => {
        component.components.forEach(button => {
          if (button.customId === customId) {
            buttons.push(button);
          }
        });
      });
      await interaction.deferUpdate();
      await trigger(interaction, ...buttons);
      this.rerender();
    }
  }
  /**
   * @hidden
   */


  async handleSelectMenu(interaction) {
    const {
      customId
    } = interaction;
    const trigger = this.triggers.get(customId);
    const menu = [];

    if (trigger) {
      this.components.forEach(component => {
        component.components.forEach(component => {
          if (component.customId === customId) {
            menu.push(component);
          }
        });
      });
      await interaction.deferUpdate();
      await trigger(interaction, ...menu);
    }
  }
  /**
   * Method for invoking quick actions
   */


  executeAction(action) {
    switch (action) {
      case _interfaces.Action.FIRST:
        if (this.currentPage === 1) {
          if (this.loop) {
            this.setPage(this.pages.length);
          }

          return;
        }

        this.setPage(1);
        break;

      case _interfaces.Action.BACK:
        if (this.currentPage === 1) {
          if (this.loop) {
            this.setPage(this.pages.length);
          }

          return;
        }

        this.setPage(this.currentPage - 1);
        break;

      case _interfaces.Action.STOP:
        this.stopListen();
        break;

      case _interfaces.Action.NEXT:
        if (this.currentPage === this.pages.length) {
          if (this.loop) {
            this.setPage(1);
          }

          return;
        }

        this.setPage(this.currentPage + 1);
        break;

      case _interfaces.Action.LAST:
        if (this.currentPage === this.pages.length) {
          if (this.loop) {
            this.setPage(1);
          }

          return;
        }

        this.setPage(this.pages.length);
        break;
    }
  }

}

exports.PagesBuilder = PagesBuilder;